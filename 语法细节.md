### 基础
+ if else 都用花括号包裹，避免else落空行为。
+ 逻辑操作符，&&-与， ||-或， !-非, ^-异或。
+ 位操作符， &-与， |-或， ~-非， ^-异或。
+ 移位操作符， <<左移，>>有符号右移，>>>无符号右移。左移乘以2^n，有符号右移除以2^n，n为移动的位数。无符号右移，正数与有符号相同，负数为不确定值。
+ Math类，向上/下取整为取数值大/小的整数。ceil(x)，向上取整，返回double；floor(x)，向下取整，返回double；round(float x)= (int)floor(x)，round(double x)=(long)floor(x)；rint(x),返回最接近的整数，相同则为偶数，double类型。

### 方法
#### 方法重载
方法重载主要看参数列表，即参数类型、数目和顺序。三者至少有一个不同且位于同一个类的作用域中方法名相同，即为方法重载。
#### 方法重写
+ 子类定义一个与父类函数头完全一样的方法
+ 重写的方法是父类中的非静态且子类可访问的方法
+ 子类重写方法时，可以使用重写标注`@override`来让编译器提供语法检查
#### 方法绑定实现原理
JVM根据继承链依次查找方法头，链头为最深的子类，找到方法就调用该方法。该继承链是子类重写了方法则添加到链头，即为重写方法继承链。
该链上的节点由最特殊子类开头，节点内容为重写的方法头。
JVM绑定方法时，首先按照实际类型定位节点，然后在节点内部查找方法头，若匹配则找到实际调用的方法，否则沿着链继续查找。
#### 参数 
+ 可变长参数，只能在参数列表最后，只能有一个，实参可为数组，方法内被当作数组。`void f(int... nums) #nums等同于数组`

### 数组
#### 一维数组
+ 声明 `typename[] var;`创建`typename[] var = new typename[nums] #nums必须指定为正整数`或者`typename[] var = {item1, ..., itemk} #item 类型为typename`
+ 数组是对象，传参是传递的是数组的引用变量，方法内改变数组，外部数组也会相应改变。
#### 多维数组
+ 多维数组是数组的数组，`typename[][] var = new typename[nums][option] #nums必须指定，option可选，var[0] = new typename[size] `

###修饰符

| 修饰符 | 类  | 类成员 | 局部变量 |
| :----: | :-: | :----: | :-----: |
| public | 无限制 | 无限制 | 不能修饰 |
| protected | 不能修饰 | 同一包或不同包子类 | 不能修饰|
| default | 同一包 | 同一包 | 方法内部 |
| private | 不能修饰 | 同一类 | 不能修饰 |
| abstract | 抽象类 | 抽象方法不能修饰数据 | 不能修饰 |
| static | 不能修饰 | 静态方法静态数据 | 不能修饰 |
| final | 最终类不能被继承 | 方法不能被重写数据不可变 | 变量值不变|
 
 ### 初始化
 + 实例变量和静态变量有默认值，基础类型char为''，byte、short、int、long为0，boolean为false，float、double为0.0。引用类型为null。
 + 局部变量没有默认值，使用之前必须赋值。
 
 ### 构造函数
 #### 构造函数特征
 + 与类同名
 + 没有返回值，跟返回值为void不同
 + 新建对象时使用，与new this super配合使用
 + this()调用当前类的构造函数，必须为重载的构造函数第一行
 + 若显式定义构造函数，默认无参构造函数也一定要显式定义，避免子类无法隐性调用默认构造函数
 + 构造函数可以为private用于单例类，protected用于抽象类。
 #### 类的构造顺序
 1. 调用最合适的构造函数，即如果第一行是用this调用其他构造函数，则调用其他构造函数
 2. 若有super调用父类构造函数则显式调用父类构造函数
 3. 若有父类但未显式调用，则调用父类默认构造函数
 4. 父类递归以上步骤
 
 ### 引用变量
 #### 声明类型
 声明类型是指声明变量时的变量类型，方法匹配是编译器根据变量的声明类型和方法签名来进行匹配。
 #### 实际类型
 实际类型是指变量实际指向的对象的类型，方法绑定是jvm根据继承链顺序查找方法进行绑定，这决定了实际调用哪个方法。
 #### 类型转换
 子类实例的类型可以隐性转化为父类类型，实际类型为子类的变量可以显式转化为子类类型`(Child)fatherVar #fatherVar实际指向Child实例`。
 类型转化的意义在于
 + 利用变量的声明类型为父类的通用性
 + 转化之后才可以调用子类的方法，不然编译器会报错
 #### 类型检测
 关键字**instanceof**可以检测变量的实际类型是否为特定的类型 `fatherVar instanceof Child #该表达式返回值为boolean`
 
 ### ArrayList
 + 范型类型必须是对象，基本类型需要使用包装类，例如Integer。
 
 ### 接口
 接口是特殊的抽象类。
 + 所有数据域修饰符为 public static final，即公共静态常量。
 + 所有方法修饰符为 public abstract , 即公共抽象方法。
 + 接口的定义`修饰符 interface name {数据域；方法} #数据域和方法的修饰符固定不变，通常省略`
 
 ### 抽象类
 + 抽象类不能被new T() 创建，其他跟普通类无任何区别
 + 抽象类可以不定义抽象方法，但有抽象方法的类必须是抽象类
 + 抽象类的构造方法必须为protected
 + 父类有抽象方法，子类没有实现所有抽象方法则必须定义为抽象类
 + 父类是普通类，子类也能定义为抽象类
 ### 抽象方法
 + 抽象方法的修饰符abstract 跟 final private static冲突，只能和public protected配合使用。
 
 ### 异常
 + 声明异常`public void f() throws Exception`
 + 抛出异常`throw new Exception("something is wrong")`
 + 捕获异常`catch(Exception e)`
 + 抛出异常的方法必须声明异常，并且调用该方法的方法要么捕获异常要么声明异常
 + 免检异常是Error和RuntimeException，无需声明抛出和捕获
 + 异常有额外开销，尽量减少异常的抛出
 + 严格避免异常当作控制条件
 
 ### IO
 #### 文本IO
 + 使用try-with-resource处理资源。资源必须是AutoClose的子类型。资源的声明和创建在同一行。
 + `try(PrintWriter out = new PrintWriter(new File("a.txt"))){#打印操作}`
 + PrintWriter用于输出，Scanner用于输入
 + PrintWriter可以通过FileOutputStream传参构造，Scanner可以通过FileInputStream传参构造
 #### 二进制IO
 + 父类InputStream和OutputStream
 + 文件子类FileInputStream和FileOutputStream, 处理二进制文件
 + 缓冲子类BufferedInputStream和BufferedOutputStream, 提高大文件读写效率
 + 基本类型和字符串子类DataInputStream和DataOutputStream, 方便处理基本类型和字符串，读写顺序和格式要对应
 + 对象子类ObjectInputStream和ObjectOutputStream, 序列化对象。
 + 对象序列化。静态数据不参与序列化，引用对象数据必须该对象是可序列化的。
 + 非可序列化的实例数据域可以用修饰符transient不参与序列化
 + 重复写入对象只存储一份，不会存储多个副本。
 
 ### 递归
 + 递归都可以转化为非递归循环的形式
 + 递归有时间和空间开销，但针对具有递归性质的问题，递归容易理解和编写代码
 + 尾递归即调用递归函数之后，无其他语句，即调用递归函数是函数体内最后一条语句
 + 尾递归能减小时间和空间开销，递归都能通过额外传递参数转化为尾递归
 
 ### 范型
 + <T>为范型类型，泛指各种类型。
 + 使用范型能在编译期检测错误
 + 定义范型类，在类名之后加上范型类型
 + 定义范型函数，在返回值之前加上范型类型
 + 可以定义受限的范型类型，`<T extands Comparable<T>>#T是可比较接口的子类`
 + 通配范型，`<?>#非受限，Object及子类` `<? extands T>#T及T的子类` `<? super T>#T及T的父类`
 #### 范型消除
 + 范型类型只在编译期有效，在运行期全部消除为Object或者受限类型
 + 所有范型实例共享范型类
 + 不能构造范型类实例或范型类数组
 + 范型类的静态数据或静态方法不能引用范型类参数，不是范型类无此限制
 + 静态方法使用范型，必须在返回值之前加上范型参数，不能直接引用范型类的范型参数
 + 异常类不能是范型的
 ### Comparable接口
 + 用于比较同一类的两个实例变量
 + `public int compareTo(T t) #小于返回-1，等于返回0，大于返回1`
 ### Comparator接口
 + 用于比较没有实现Comparable接口的类的实例
 + `public int compare(T t1, T t2) #t1小于t2返回-1，等于返回0，大于返回1`
 
 ### 集合框架
 + ArrayList,数组线性表。有序，动态扩容，支持下标操作。
 + LinkedList,链表。有序，动态扩容，不支持下标，头尾插入删除快速，支持双端队列操作
 + Vector。与ArrayList相似，区别在于Vector插入删除元素时支持同步。
 + Stack，栈。有序，动态扩容，先进后出。
 + PriorityQueue，优先队列。按照权重出队，默认最小的元素最先出队。
 + 线性表，栈，队列都能有重复元素。
 + HashSet,哈希集。元素不重复，无序。
 + LinkedHashSet,链接哈希集。按照元素插入顺序排序
 + TreeSet，树形集。默认按照元素的Comparable或者Comparator接口排序
 + 线性表，栈，队列和集合都支持迭代器，能直接用foreach遍历
 + HashMap，映射表。键值对存储，键唯一，值可重复。无序，且不支持迭代器。
 + LinkedHashMap，链接映射表。按照元素插入顺序或者修改顺序排序。
 + TreeMap，树形表。按照元素Comparable或者Comparator接口排序。
 + Hashtable是同步的HashMap
 + 映射表的遍历需要将所有条目或者键转为集合，利用集合的遍历方法来遍历。
 + 集合框架的泛型类型必须为对象，即基本类型要用包装类
 ### 散列
 + 散列函数的功能是将键转化为哈希表的下标。最完美的情况就是下标唯一，得到不唯一的下标是很难避免的，即冲突。
 + 散列函数首先将键转化为一个int即哈希码，再将哈希码压缩为下标
 #### 散列码
 + 不同对象的哈希码有可能相同，例如两个空哈希集
 + 同一对象更新数据域，哈希码不会更新，即哈希码与数据域相互绑定。
 + byte char short int 类型对象的散列码是对象值转为int值，float类型对象将值转为32位bit表示，该32位bit当作int型的散列码。
 + long对象`code = (int)key ^ (key >> 32) #折叠`，double对象将值转为64位bit的long型对象，然后按照long对象计算哈希码
 + byte char short int float对象的哈希码是唯一的，long double对象的哈希码是不唯一的。
 + String对象哈希码`code = Σsi * b^(i)#b=31`，字符串太长哈希码会溢出，因此String对象的哈希码也不唯一
 + 下标的压缩`h(hashCode) = hashCode % N = hashCode & (N - 1)#N为2的幂次方，加快计算速度`
 + `h(hashCode) = supplementalHash(hashCode) & (N - 1)`
 ```private int supplementalHash(h){
        h ^= (h >>> 20) ^ (h >>> 12);
        return h ^ (h >>> 7) ^ (h >>> 4); 
    }
```
#### 冲突处理
+ 线性探测 `key = key + j #key为下标，j为冲突次数`容易成簇，可用空间少，装填因子不大于0.5
+ 平方探测 `key = key + j^2`容易二次成簇，且不保证一定能找到空下标
+ 再哈希 `key = key + j * h'(key)`利用第二个哈希函数根据key生成增量
+ 链地址法，冲突的key形成一个链表，可用空间大，装填因子不大于0.9
#### 装填因子与再散列
+ 装填因子，哈希表实际大小与容量的比值，装填因子越大越容易冲突
+ 当装填因子过大，需要进行再散列，即将哈希表的容量翻倍，将已有键值对复制到新的哈希表
